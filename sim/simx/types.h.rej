diff a/sim/simx/types.h b/sim/simx/types.h	(rejected hunks)
@@ -1,10 +1,10 @@
 // Copyright Â© 2019-2023
-// 
+//
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 // http://www.apache.org/licenses/LICENSE-2.0
-// 
+//
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an "AS IS" BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -65,7 +65,7 @@ enum class RegType {
 inline std::ostream &operator<<(std::ostream &os, const RegType& type) {
   switch (type) {
   case RegType::None: break;
-  case RegType::Integer: os << "x"; break;  
+  case RegType::Integer: os << "x"; break;
   case RegType::Float:   os << "f"; break;
   default: assert(false);
   }
@@ -247,13 +249,13 @@ struct MemReq {
   bool     write;
   AddrType type;
   uint32_t tag;
-  uint32_t cid;    
+  uint32_t cid;
   uint64_t uuid;
 
-  MemReq(uint64_t _addr = 0, 
+  MemReq(uint64_t _addr = 0,
           bool _write = false,
           AddrType _type = AddrType::Global,
-          uint64_t _tag = 0, 
+          uint64_t _tag = 0,
           uint32_t _cid = 0,
           uint64_t _uuid = 0
   ) : addr(_addr)
@@ -276,12 +278,12 @@ inline std::ostream &operator<<(std::ostream &os, const MemReq& req) {
 ///////////////////////////////////////////////////////////////////////////////
 
 struct MemRsp {
-  uint64_t tag;    
+  uint64_t tag;
   uint32_t cid;
   uint64_t uuid;
-  
+
   MemRsp(uint64_t _tag = 0, uint32_t _cid = 0, uint64_t _uuid = 0)
-    : tag (_tag) 
+    : tag (_tag)
     , cid(_cid)
     , uuid(_uuid)
   {}
@@ -297,16 +299,16 @@ inline std::ostream &operator<<(std::ostream &os, const MemRsp& rsp) {
 
 template <typename T>
 class HashTable {
-public:    
+public:
   HashTable(uint32_t capacity)
     : entries_(capacity)
-    , size_(0) 
+    , size_(0)
   {}
 
   bool empty() const {
     return (0 == size_);
   }
-  
+
   bool full() const {
     return (size_ == entries_.size());
   }
@@ -337,7 +339,7 @@ public:
       if (!entry.first) {
         entry.first = true;
         entry.second = value;
-        ++size_;              
+        ++size_;
         return i;
       }
     }
@@ -374,13 +376,13 @@ public:
   std::vector<SimPort<Type>> Outputs;
 
   Mux(
-    const SimContext& ctx, 
-    const char* name, 
-    ArbiterType type, 
-    uint32_t num_inputs, 
+    const SimContext& ctx,
+    const char* name,
+    ArbiterType type,
+    uint32_t num_inputs,
     uint32_t num_outputs = 1,
     uint32_t delay = 1
-  ) : SimObject<Mux<Type>>(ctx, name)    
+  ) : SimObject<Mux<Type>>(ctx, name)
     , Inputs(num_inputs, this)
     , Outputs(num_outputs, this)
     , type_(type)
@@ -388,13 +390,13 @@ public:
     , cursors_(num_outputs, 0)
     , num_reqs_(num_inputs / num_outputs)
   {
-    assert(delay != 0);    
+    assert(delay != 0);
     assert(num_inputs <= 32);
     assert(num_outputs <= 32);
     assert(num_inputs >= num_outputs);
 
     // bypass mode
-    if (num_inputs == num_outputs) {      
+    if (num_inputs == num_outputs) {
       for (uint32_t i = 0; i < num_inputs; ++i) {
         Inputs.at(i).bind(&Outputs.at(i));
       }
@@ -415,20 +417,20 @@ public:
     // skip bypass mode
     if (I == O)
       return;
-        
-    // process inputs       
+
+    // process inputs
     for (uint32_t o = 0; o < O; ++o) {
       for (uint32_t r = 0; r < R; ++r) {
         uint32_t i = (cursors_.at(o) + r) & (R-1);
         uint32_t j = o * R + i;
         if (j >= I)
           continue;
-        
+
         auto& req_in = Inputs.at(j);
         if (!req_in.empty()) {
           auto& req = req_in.front();
           DT(4, this->name() << "-" << req);
-          Outputs.at(o).push(req, delay_);                
+          Outputs.at(o).push(req, delay_);
           req_in.pop();
           this->update_cursor(o, i);
           break;
@@ -446,7 +448,7 @@ private:
   }
 
   ArbiterType type_;
-  uint32_t delay_;  
+  uint32_t delay_;
   std::vector<uint32_t> cursors_;
   uint32_t num_reqs_;
 };
@@ -459,33 +461,33 @@ public:
   std::vector<SimPort<Req>>  ReqIn;
   std::vector<SimPort<Rsp>>  RspIn;
 
-  std::vector<SimPort<Req>>  ReqOut;  
+  std::vector<SimPort<Req>>  ReqOut;
   std::vector<SimPort<Rsp>>  RspOut;
 
   Switch(
-    const SimContext& ctx, 
-    const char* name, 
-    ArbiterType type, 
-    uint32_t num_inputs, 
+    const SimContext& ctx,
+    const char* name,
+    ArbiterType type,
+    uint32_t num_inputs,
     uint32_t num_outputs = 1,
     uint32_t delay = 1
-  ) 
-    : SimObject<Switch<Req, Rsp>>(ctx, name)    
+  )
+    : SimObject<Switch<Req, Rsp>>(ctx, name)
     , ReqIn(num_inputs, this)
     , RspIn(num_inputs, this)
-    , ReqOut(num_outputs, this)    
+    , ReqOut(num_outputs, this)
     , RspOut(num_outputs, this)
     , type_(type)
     , delay_(delay)
     , cursors_(num_outputs, 0)
     , lg_num_reqs_(log2ceil(num_inputs / num_outputs))
   {
-    assert(delay != 0);    
+    assert(delay != 0);
     assert(num_inputs <= 32);
     assert(num_outputs <= 32);
     assert(num_inputs >= num_outputs);
 
-    // bypass mode    
+    // bypass mode
     if (num_inputs == num_outputs) {
       for (uint32_t i = 0; i < num_inputs; ++i) {
         ReqIn.at(i).bind(&ReqOut.at(i));
@@ -508,7 +510,7 @@ public:
     // skip bypass mode
     if (I == O)
       return;
-        
+
     for (uint32_t o = 0; o < O; ++o) {
       // process incoming responses
       if (!RspOut.at(o).empty()) {
@@ -517,10 +519,10 @@ public:
         if (lg_num_reqs_ != 0) {
           i = rsp.tag & (R-1);
           rsp.tag >>= lg_num_reqs_;
-        }      
+        }
         DT(4, this->name() << "-" << rsp);
         uint32_t j = o * R + i;
-        RspIn.at(j).push(rsp, 1);      
+        RspIn.at(j).push(rsp, 1);
         RspOut.at(o).pop();
       }
 
@@ -530,7 +532,7 @@ public:
         uint32_t j = o * R + i;
         if (j >= I)
           continue;
-        
+
         auto& req_in = ReqIn.at(j);
         if (!req_in.empty()) {
           auto& req = req_in.front();
@@ -538,7 +540,7 @@ public:
             req.tag = (req.tag << lg_num_reqs_) | i;
           }
           DT(4, this->name() << "-" << req);
-          ReqOut.at(o).push(req, delay_);                
+          ReqOut.at(o).push(req, delay_);
           req_in.pop();
           this->update_cursor(o, i);
           break;
@@ -555,7 +557,7 @@ public:
 
 private:
   ArbiterType type_;
-  uint32_t delay_;  
+  uint32_t delay_;
   std::vector<uint32_t> cursors_;
   uint32_t lg_num_reqs_;
 };
@@ -576,8 +578,8 @@ public:
   SimPort<MemRsp> RspDC;
 
   LocalMemDemux(
-    const SimContext& ctx, 
-    const char* name, 
+    const SimContext& ctx,
+    const char* name,
     uint32_t delay
   );
 
